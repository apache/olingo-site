<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- 
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License. 
-->
<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Apache Olingo provides libraries which enable developers to implement OData producers and OData consumers. The available OData Java library implements OData version 2.0. In future on goal is to provide an OData 4.0 compliant library once the OData standard is published at OASIS. The focus within the community is currently on the Java technology but it is up to the community to discuss if other environments find interest.">
    <meta name="author" content="">
    <link rel="icon" href="/favicon.ico">
    <title>Apache Olingo Library</title>
    <!-- Bootstrap core CSS -->
    <link href="/css/bootstrap.css" rel="stylesheet" type="text/css"><!-- Custom styles for this template -->
    <link href="/css/navbar.css" rel="stylesheet" type="text/css"><!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <link href="/css/offcanvas.css" rel="stylesheet" type="text/css"><!-- Custom styles for this template -->
    <link rel="stylesheet" href="/css/main.css">
    <!--[if lt IE 9]><script src="/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <style>
.headerlink {
  visibility: hidden;
}
dt:hover > .headerlink, p:hover > .headerlink, td:hover > .headerlink, h1:hover > .headerlink, h2:hover > .headerlink, h3:hover > .headerlink, h4:hover > .headerlink, h5:hover > .headerlink, h6:hover > .headerlink {
  visibility: visible
}    </style>
    <script src="/js/ie-emulation-modes-warning.js" type="text/javascript">
</script><!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->

    <script src="/js/ie10-viewport-bug-workaround.js" type="text/javascript">
</script><!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.min.js"></script>
      <script src="/js/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="container">
      <!-- Static navbar -->
      <div class="navbar navbar-default" role="navigation">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
            </button>
              <img class="navbar-brand" src="/img/OlingoOrangeTM.png" style="width:62px;" >
              <a class="navbar-brand" href="/">Apache Olingo™</a>
          </div>
          <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
              <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown">ASF <b class="caret"></b></a>
                  <ul class="dropdown-menu">
                      <li><a href="http://www.apache.org/foundation/">ASF Home</a></li>
                      <li><a href="http://projects.apache.org/">Projects</a></li>
                      <li><a href="http://people.apache.org/">People</a></li>
                      <li><a href="http://www.apache.org/foundation/getinvolved.html">Get Involved</a></li>
                      <li><a href="http://www.apache.org/dyn/closer.cgi">Download</a></li>
                      <li><a href="http://www.apache.org/security/">Security</a></li>
                      <li><a href="http://www.apache.org/foundation/sponsorship.html">Support Apache</a></li>
                  </ul>
              </li>

              <li><a href="http://www.apache.org/licenses/">License</a></li>

              <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Download <b class="caret"></b></a>
                  <ul class="dropdown-menu">
                      <li><a href="/doc/odata2/download.html">Download OData 2.0 Java</a></li>
                      <li><a href="/doc/odata4/download.html">Download OData 4.0 Java</a></li>
                      <li><a href="/doc/javascript/download.html">Download OData 4.0 JavaScript</a></li>
                  </ul>
              </li>

              <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
                  <ul class="dropdown-menu">
                    <li><a href="/doc/odata2/index.html">Documentation OData 2.0 Java</a></li>
                    <li><a href="/doc/odata4/index.html">Documentation OData 4.0 Java</a></li>
                    <li><a href="/doc/javascript/index.html">Documentation OData 4.0 JavaScript</a></li>
                  </ul>
              </li>
              <li><a href="/support.html">Support</a></li>
              <li><a href="/contribute.html">Contribute</a></li>

            </ul>

			  <a class="navbar-right" href="http://www.apache.org/foundation/" target="_blank">
          <img class="navbar-right" height="50px" src="/img/asf_logo_url.svg" alt="Apache Software Foundation">
        </a>

			</div><!--/.nav-collapse -->
        </div><!--/.container-fluid -->
      </div><!-- Main component for a primary marketing message or call to action -->
    <h1 id="how-to-build-an-odata-service-with-olingo-v4">How to build an OData Service with Olingo V4<a class="headerlink" href="#how-to-build-an-odata-service-with-olingo-v4" title="Permalink">&para;</a></h1>
<h1 id="add-streaming-support-for-entity-collections">Add Streaming Support (for Entity Collections)<a class="headerlink" href="#add-streaming-support-for-entity-collections" title="Permalink">&para;</a></h1>
<p>Available with <em>Apache Olingo 4.2.0 (and newer).</em></p>
<h2 id="preface">Preface<a class="headerlink" href="#preface" title="Permalink">&para;</a></h2>
<p>In the present tutorial we will add streaming support for Entity Collections on a per Entity granularity.</p>
<p><strong>Note:</strong>
The final source code can be found in the project <a href="https://gitbox.apache.org/repos/asf/olingo-odata4">git repository</a>.<br/>
A detailed description how to checkout the tutorials can be found <a href="/doc/odata4/tutorials/prerequisites/prerequisites.html">here</a>.<br/>
This tutorial can be found in the <code>DemoService-Streaming</code> module in the projects subdirectory <code>/samples/tutorials/pe_streaming</code></p>
<p><strong>Table of Contents</strong></p>
<ol>
<li>Introduction</li>
<li>Preparation</li>
<li>Implementation</li>
<li>Run the implemented service</li>
<li>Links</li>
</ol>
<h1 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permalink">&para;</a></h1>
<p>The actual <em>streaming support</em> in the Olingo library enables a way to provide an Entity Collection on a single Entity granularity. This enables support for e.g. <em>chunked HTTP responses</em> without the need to have the whole Entity Collection pre-loaded (and probably in memory). Therefore the <code>EntityIterator</code> interface is used to check for additional entities and to provide the next available entity. The how a single Entity is provided is than completely based on the decision of the service developer.</p>
<p>A possible implementation then could e.g. pre-load ten entities and serve them as <em>chunked HTTP responses</em> and first with the next requested chunkes the next (ten) entities would be loaded from the database. With such an implementation the runtime memory consumption could be reduced (with the counterpart of more database round trips) and the client has the possibility to visualise the already delivered entities (if the client support this).</p>
<h1 id="preparation">Preparation<a class="headerlink" href="#preparation" title="Permalink">&para;</a></h1>
<p>You should read the previous tutorials first to have an idea how to read entity collections. In addition the following code is based on the <a href="/doc/odata4/tutorials/readep/tutorial_readep.html">read collection tutorial (Part 2)</a>.</p>
<p>As a shortcut for the upcoming modification steps you should checkout the mentioned tutorial project. It is available in the git repository in folder <code>/samples/tutorials/p2_readep</code> (for more information about checkout see in the <a href="/doc/odata4/tutorials/readep/tutorial_readep.html">read collection tutorial (Part 2)</a>).</p>
<p>The main idea of the following implementation is to enable a basic streaming support in the sample <em>data provider</em> (the <code>Storage</code> class) and use this in the already existing processors.</p>
<p>Therefore following steps have to be performed:</p>
<ul>
<li>Modify the <em>data provider</em> (the <code>Storage</code> class)
<ul>
<li>Includes a basic implementation of the <code>EntityIterator</code> interface</li>
</ul>
</li>
<li>Use the <code>EntityIterator</code> in the <code>readEntityCollection(..)</code> method</li>
<li>Optional: Add exception/error handling (with <code>ODataContentWriteErrorCallback</code>)</li>
</ul>
<h1 id="implementation">Implementation<a class="headerlink" href="#implementation" title="Permalink">&para;</a></h1>
<p>To enable the <em>streaming support</em> in a service there are following steps which need to be done:</p>
<ol>
<li>An <code>EntityIterator</code> implementation has to be used to provide the entity collection data (<code>Entity</code> objects)</li>
<li>This <code>EntityIterator</code> has to be passed to the <code>entityCollectionStreamed(...)</code> method of the used <code>ODataSerializer</code></li>
<li>The <code>ODataSerializer</code> than returns a <code>SerializerStreamResult</code> which contains the <em>stream enabled</em> result within a <code>ODataContent</code> object.</li>
<li>The <code>ODataContent</code> is then set at the <code>ODataResponse</code> via the <code>setODataContent(...)</code> method</li>
</ol>
<p>Basically it is the same as in the <em>none streaming</em> with the difference that some other objects and classes has to be used.</p>
<p>For demonstration of above steps the existing <a href="/doc/odata4/tutorials/readep/tutorial_readep.html">read collection tutorial</a> will be now enabled for <em>streaming of entity collections</em>.</p>
<h2 id="simplest-approach">Simplest approach<a class="headerlink" href="#simplest-approach" title="Permalink">&para;</a></h2>
<p>The <em>simplest approach</em> is to wrap the already existing <code>EntityCollection</code> into an <code>EntityIterator</code> and pass this to the according <code>entityCollectionStreamed(...)</code> method.
With this the service would not change how the data is accessed but would (easily) enable the possibility for a (streamed) <em>chunked HTTP response</em> (if this is supported by the environment e.g. JEE application server).</p>
<p>In the existing <a href="/doc/odata4/tutorials/readep/tutorial_readep.html">read collection tutorial</a> following new method is necessary to create an <code>EntityIterator</code> to wrap an <code>EntityCollection</code>:</p>
<pre><code class="language-java">    private EntityIterator wrapAsIterator(final EntityCollection collection) {
      final Iterator&lt;Entity&gt; it = collection.iterator();
      return new EntityIterator() {
        @Override
        public boolean hasNext() {
          return it.hasNext();
        }

        @Override
        public Entity next() {
          return it.next();
        }
      };
    }
</code></pre>
<p>The (as anonymous inner class) created <code>EntityIterator</code> only iterates over the already loaded entities (of the <code>EntityCollection</code>).</p>
<p>To use this <code>EntityIterator</code> in the <code>readEntityCollection(..)</code> method the <code>EntityIterator</code> must be passed to the <code>ODataSerializer</code> via the <code>entityCollectionStreamed(...)</code> method and the <code>ODataContent</code> object of the resulting <code>SerializerStreamResult</code> must be set at the <code>ODataResponse</code> via the <code>setODataContent(...)</code> method.
What sound like a lot to do is just the below code snippet:</p>
<pre><code class="language-java">      ...
      EntityIterator iterator = wrapAsIterator(entityCollection);
      SerializerStreamResult serializerResult = serializer.entityCollectionStreamed(serviceMetadata,
          edmEntityType, iterator, opts);

      // 4th: configure the response object: set the body, headers and status code
      response.setODataContent(serializerResult.getODataContent());
      ...
    }
</code></pre>
<p>Which replaces following original code snippet:</p>
<pre><code class="language-java">      ...
      SerializerResult serializerResult = serializer.entityCollection(serviceMetadata,
          edmEntityType, entityCollection, opts);

      // 4th: configure the response object: set the body, headers and status code
      response.setContent(serializedContent);
      ...
    }
</code></pre>
<h2 id="dataprovider-based-approach">DataProvider based approach<a class="headerlink" href="#dataprovider-based-approach" title="Permalink">&para;</a></h2>
<p>The <em>realistic approach</em> is that the data provider (e.g. a database) creates an <code>EntityIterator</code> which is used to provide the entity collection data (<code>Entity</code> objects) to the <code>EntityProcessor</code> and <code>ODataSerializer</code>.</p>
<p>With this approach not only the option for a (streamed) chunked HTTP response (if this is supported by the environment e.g. JEE application server) is enabled. Furthermore the data provider is in charge at which time how many entities are loaded (and hold) in memory.
This means as example, that a data provider can implement a concept of lazy loading of the entity collection in which e.g. a database connection is established but only the first ten entities are loaded in memory and passed for response serialization. First when the serializer need the eleventh (and/or more) entity those are loaded from the database (and the first ten can be removed from memory).
Practically such an approach requires more database roundtrips but also a smaller memory footprint and less eager loading at the begin of the request/response cycle.</p>
<p>In the existing <a href="/doc/odata4/tutorials/readep/tutorial_readep.html">read collection tutorial</a> the <code>Storage</code> class is used a data provider (acting like a database).
For enablement of the <em>streaming support</em> following new method is introduced which create an <code>EntityIterator</code> to allow the iterable passed access to the stored entities:</p>
<pre><code class="language-java">    public EntityIterator readEntitySetDataStreamed(EdmEntitySet edmEntitySet)throws ODataApplicationException {
      // actually, this is only required if we have more than one Entity Sets
      if(edmEntitySet.getName().equals(DemoEdmProvider.ES_PRODUCTS_NAME)){
        final Iterator&lt;Entity&gt; it = productList.iterator();
        return new EntityIterator() {
          @Override
          public boolean hasNext() {
            return it.hasNext();
          }

          @Override
          public Entity next() {
            return it.next();
          }
        };
      }

      return null;
    }
</code></pre>
<p>As described above in the existing implementation the use of the <code>EntityCollection</code> has to be replaced with the <code>EntityIterator</code>, which means that this line:
<code>EntityCollection entityCollection = storage.readEntitySetData(edmEntitySet);</code>
has to be replaced by that line:
<code>EntityIterator iterator = storage.readEntitySetDataStreamed(edmEntitySet);</code></p>
<p>And the</p>
<pre><code class="language-java">    SerializerResult serializerResult = serializer.entityCollection(
      serviceMetadata, edmEntityType, entityCollection, opts);
</code></pre>
<p>has to be replaced by</p>
<pre><code class="language-java">    SerializerStreamResult serializerResult = serializer.entityCollectionStreamed(
      serviceMetadata, edmEntityType, iterator, opts);
</code></pre>
<p>And at the <code>ODataResponse</code> now instead of:
<code>response.setContent(serializerResult.getContent());</code>
the result is set as <code>ODataContent</code>:
<code>response.setODataContent(serializerResult.getODataContent());</code></p>
<p>As result the whole <code>readEntityCollection(...)</code> method now look like following:</p>
<pre><code class="language-java">    public void readEntityCollection(ODataRequest request, ODataResponse response, UriInfo uriInfo, ContentType responseFormat) throws ODataApplicationException, SerializerException {

      // 1st retrieve the requested EntitySet from the uriInfo (representation of the parsed URI)
      List&lt;UriResource&gt; resourcePaths = uriInfo.getUriResourceParts();
      UriResourceEntitySet uriResourceEntitySet = (UriResourceEntitySet) resourcePaths.get(0); // in our example, the first segment is the EntitySet
      EdmEntitySet edmEntitySet = uriResourceEntitySet.getEntitySet();

      // 2nd: fetch the data from backend for this requested EntitySetName and deliver as EntitySet
      EntityIterator iterator = storage.readEntitySetDataStreamed(edmEntitySet);

      // 3rd: create a serializer based on the requested format (json)
      ODataSerializer serializer = odata.createSerializer(responseFormat);

      // and serialize the content: transform from the EntitySet object to InputStream
      EdmEntityType edmEntityType = edmEntitySet.getEntityType();
      ContextURL contextUrl = ContextURL.with().entitySet(edmEntitySet).build();

      final String id = request.getRawBaseUri() + "/" + edmEntitySet.getName();
      EntityCollectionSerializerOptions opts = EntityCollectionSerializerOptions.with().id(id)
              .contextURL(contextUrl).build();

      SerializerStreamResult serializerResult = serializer.entityCollectionStreamed(serviceMetadata,
          edmEntityType, iterator, opts);

      // 4th: configure the response object: set the body, headers and status code
      response.setODataContent(serializerResult.getODataContent());
      response.setStatusCode(HttpStatusCode.OK.getStatusCode());
      response.setHeader(HttpHeader.CONTENT_TYPE, responseFormat.toContentTypeString());
    }
</code></pre>
<p>After this changes the data access (encapsulated in the <code>EntityIterator</code>) and serialization is now done directly when the data is processed by the web framework layer (e.g. JEE servlet layer) and not within the call hierarchy of the <code>readEntityCollection(...)</code> method.</p>
<p>The <em>counterpart</em> of this is that when an error/exception occurs during the serialization of the data the <code>readEntityCollection(...)</code> method already returned and hence there is no possibility (at this point) to catch the exception and do an error handling.
Furthermore because of the <em>streaming</em> the <em>HTTP Header</em> is already sent to the client (with e.g. a <code>HTTP Status-Code: 200 OK</code>).
Based on this the <em>OData-v4.0 Part1 Protocol</em> describes in chapter <em>9.4 In-Stream Errors</em> how to handle this:</p>
<blockquote>
<p>In the case that the service encounters an error after sending a success status to the client, the service MUST generate an error within the payload, which may leave the response malformed. Clients MUST treat the entire response as being in error. This specification does not prescribe a particular format for generating errors within a payload.</p>
</blockquote>
<p>And for Olingo exists the <code>ODataContentWriteErrorCallback</code> which is described in the chapter <em>Exception/Error Handling</em>.</p>
<h3 id="more-realistic-data-provider">More realistic data provider<a class="headerlink" href="#more-realistic-data-provider" title="Permalink">&para;</a></h3>
<p>Because the simplistic data provider in the tutorial the <code>EntityIterator</code> is also very simplistic.
However it is also realistic to have an <code>EntityIterator</code> which e.g. access a database result set which is <code>next():Entity</code> call (see below code snippet to get the idea).</p>
<pre><code class="language-java">    public class MyEntityIterator extends EntityIterator {
      ResultSet set; //...

      public MyEntityIterator(ResultSet set) {
        this.set = set;
      }

      @Override
      public boolean hasNext() {
        return set.next();
      }

      @Override
      public Entity next() {
        return readNextEntityFromResultSet();
      }

      private Entity readNextEntityFromResultSet() {
        // read data from result set and return as entity object
      }
    }
</code></pre>
<h2 id="exceptionerror-handling">Exception/Error Handling<a class="headerlink" href="#exceptionerror-handling" title="Permalink">&para;</a></h2>
<p>The <em>counterpart</em> of the <em>streaming support</em> is that when an error/exception occurs during the serialization of the data the service implementation is not in charge anymore to catch the exception and do an error handling.</p>
<p>Furthermore because of the <em>streaming</em> the <em>HTTP Header</em> is already sent to the client (with e.g. a <code>HTTP Status-Code: 200 OK</code>).
Based on this the <em>OData-v4.0 Part1 Protocol</em> describes in chapter <em>9.4 In-Stream Errors</em> how to handle this:</p>
<blockquote>
<p>In the case that the service encounters an error after sending a success status to the client, the service MUST generate an error within the payload, which may leave the response malformed. Clients MUST treat the entire response as being in error. This specification does not prescribe a particular format for generating errors within a payload.</p>
</blockquote>
<p>For <em>exception/error handling</em> in Olingo exists the <code>ODataContentWriteErrorCallback</code> interface which must be implemented and then can be set as an option at the <code>EntityCollectionSerializerOptions</code> with the <code>writeContentErrorCallback(...)</code> method.</p>
<p>If during processing (<em>write</em>) of the <code>ODataContent</code> object (normally serialization into an according <code>OutputStream</code>, like the <code>javax.servlet.ServletOutputStream</code> in a JEE servlet environment) an exception occurs the <code>ODataContentWriteErrorCallback</code> <code>handleError</code> method is called.
This method get as parameter the <code>ODataContentWriteErrorContext</code> which contains at least the thrown and to be handled <code>Exception</code> and the <code>WritableByteChannel</code> in which the payload of the response was written before the error occurred.
Based on the requirements of the OData specification that <em>the service MUST generate an error within the payload, which may leave the response malformed</em> the <code>WritableByteChannel</code> is still open and the service developer can write additional data to ensure that the response payload is malformed.</p>
<p>A basic <code>ODataContentWriteErrorCallback</code> implementation could look like this code snippet:</p>
<pre><code class="language-java">    private ODataContentWriteErrorCallback errorCallback = new ODataContentWriteErrorCallback() {
      public void handleError(ODataContentWriteErrorContext context, WritableByteChannel channel) {
        String message = "An error occurred with message: ";
        if(context.getException() != null) {
          message += context.getException().getMessage();
        }
        try {
          channel.write(ByteBuffer.wrap(message.getBytes()));
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
    };
</code></pre>
<p>And could be set in the <a href="/doc/odata4/tutorials/readep/tutorial_readep.html">read collection tutorial</a> at the <code>EntityCollectionSerializerOptions</code> via the <code>.writeContentErrorCallback(errorCallback)</code> method.</p>
<pre><code class="language-java">    EntityCollectionSerializerOptions opts =
        EntityCollectionSerializerOptions.with().id(id)
            .writeContentErrorCallback(errorCallback)
            .contextURL(contextUrl).build();
</code></pre>
<h1 id="run-sample-service">Run sample service<a class="headerlink" href="#run-sample-service" title="Permalink">&para;</a></h1>
<p>After building and deploying your service to your server, you can try a requests to the entity set via: <a href="http://localhost:8080/DemoService/DemoService.svc/Products?$format=json">http://localhost:8080/DemoService/DemoService.svc/Products?$format=json</a></p>
<p>The response is exactly the same response as in the none streaming request. So unfortunaly here is no difference beside of the technical fact that the response is serialized at the very end of the request chain and directly written into the response output stream (<code>javax.servlet.ServletOutputStream</code>)</p>
<pre><code class="language-json">    {
      "@odata.context": "$metadata#Products",
      "value": [
        {
          "ID": 1,
          "Name": "Notebook Basic 15",
          "Description": "Notebook Basic, 1.7GHz - 15 XGA - 1024MB DDR2 SDRAM - 40GB"
        },
        {
          "ID": 2,
          "Name": "1UMTS PDA",
          "Description": "Ultrafast 3G UMTS/HSDPA Pocket PC, supports GSM network"
        },
        {
          "ID": 3,
          "Name": "Ergo Screen",
          "Description": "19 Optimum Resolution 1024 x 768 @ 85Hz, resolution 1280 x 960"
        }
      ]
    }
</code></pre>
<h1 id="links">Links<a class="headerlink" href="#links" title="Permalink">&para;</a></h1>
<h3 id="tutorials">Tutorials<a class="headerlink" href="#tutorials" title="Permalink">&para;</a></h3>
<p>Further topics to be covered by follow-up tutorials:</p>
<ul>
<li>Tutorial OData V4 service part 1: <a href="/doc/odata4/tutorials/read/tutorial_read.html">Read Entity Collection</a></li>
<li>Tutorial OData V4 service part 2: <a href="/doc/odata4/tutorials/readep/tutorial_readep.html">Read Entity, Read Property</a></li>
<li>Tutorial OData V4 service part 3: <a href="/doc/odata4/tutorials/write/tutorial_write.html">Write (Create, Update, Delete Entity)</a></li>
<li>Tutorial OData V4 service, part 4: <a href="/doc/odata4/tutorials/navigation/tutorial_navigation.html">Navigation</a></li>
<li>Tutorial OData V4 service, part 5.1: <a href="/doc/odata4/tutorials/sqo_tcs/tutorial_sqo_tcs.html">System Query Options $top, $skip, $count (this page)</a></li>
<li>Tutorial OData V4 service, part 5.2: <a href="/doc/odata4/tutorials/sqo_es/tutorial_sqo_es.html">System Query Options $select, $expand</a></li>
<li>Tutorial OData V4 service, part 5.3: <a href="/doc/odata4/tutorials/sqo_o/tutorial_sqo_o.html">System Query Options $orderby</a></li>
<li>Tutorial OData V4 service, part 5.4: <a href="/doc/odata4/tutorials/sqo_f/tutorial_sqo_f.html">System Query Options $filter</a></li>
<li>Tutorial OData V4 service, part 6: <a href="/doc/odata4/tutorials/action/tutorial_action.html">Action and Function Imports</a></li>
<li>Tutorial OData V4 service, part 7: <a href="/doc/odata4/tutorials/media/tutorial_media.html">Add Media entities to the service</a></li>
<li>Tutorial OData V4 service, part 8: <a href="/doc/odata4/tutorials/batch/tutorial_batch.html">Batch request support</a></li>
<li>Tutorial OData V4 service, part 9: <a href="/doc/odata4/tutorials/deep_insert/tutorial_deep_insert.html">Handling "Deep Insert" requests</a></li>
</ul>
<h3 id="code-and-repository">Code and Repository<a class="headerlink" href="#code-and-repository" title="Permalink">&para;</a></h3>
<ul>
<li><a href="https://gitbox.apache.org/repos/asf/olingo-odata4">Git Repository</a></li>
<li><a href="/doc/odata4/tutorials/prerequisites/prerequisites.html">Guide - To fetch the tutorial sources</a></li>
<li><a href="http://www.apache.org/dyn/closer.lua/olingo/odata4/4.0.0/DemoService_Tutorial.zip">Demo Service source code as zip file (contains all tutorials)</a></li>
</ul>
<h3 id="further-reading">Further reading<a class="headerlink" href="#further-reading" title="Permalink">&para;</a></h3>
<ul>
<li><a href="http://odata.org/">Official OData Homepage</a></li>
<li><a href="http://www.odata.org/documentation/">OData documentation</a></li>
<li><a href="/javadoc/odata4/index.html">Olingo Javadoc</a></li>
</ul>

      <div align="center">
	<p>Copyright © 2013-2022, The Apache Software Foundation<br>
				                Apache Olingo, Olingo, Apache, the Apache feather, and
				the Apache Olingo project logo are trademarks of the Apache Software
				Foundation.</p>
        <small><a href="/doc/odata2/privacy.html">Privacy</a></small>
      </div>
    </div><!-- /container -->
    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/js/jquery.js" type="text/javascript">
    </script>
    <script src="/js/bootstrap.js" type="text/javascript">
    </script>
    <script src="/js/offcanvas.js" type="text/javascript">
    </script>
    <link rel="stylesheet" href="/css/docco.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.0.1/build/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
  </body>
</html>